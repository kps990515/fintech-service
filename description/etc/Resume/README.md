# 삼성카드 소비분석 및 연간명세서 프로젝트

**프로젝트 기간:** 
- 삼성카드 소비분석 : 2021년 11월 ~ 2022년 8월
- 삼성카드 소비분석 연간명세서 : 2022년 12월 ~2023년 1월  
**기술 스택:** Spring Boot, Microservices Architecture (MSA), Feign Client, MyBatis, Redis

## 주요 업무 및 성과:
- **금융 데이터 분석 및 소비 패턴 파악:**  
  월평균 10만 명의 순사용자를 대상으로 고객 소비 패턴 분석 및 가맹점 승인, 중복 거래 탐지, 특이 거래 식별 등을 통해 카드 사용 실적 데이터를 종합적으로 분석. 이를 바탕으로 고객 맞춤형 금융 상품 추천 및 소비 분석 리포트 제공.

- **배치 시스템을 통한 대규모 데이터 처리:**  
  중복 승인, 특이 거래, 해외 결제, 업종별 실적 등 22가지 금융 거래 데이터를 정기적인 배치 작업을 통해 관리. 일, 월, 분기, 연 단위로 실적을 집계하고 삭제하는 배치 설계를 통해 고객에게 소비 정보를 제공.

- **소비분석 API 설계 및 배포:**  
  금융 소비 데이터를 기간계 시스템과 연동하여 실시간 소비 분석 서비스를 제공. 월간, 분기별 소비 현황, 가맹점 이용 순위, 해외 결제 내역 등을 실시간으로 확인할 수 있는 API를 설계하여 금융 비즈니스의 확장성을 강화.

## 개선 사항:
- **데이터 호출 및 API 성능 30% 최적화:**  
  각 MSA 서비스의 DB 및 기간계 API를 분석하여 필요한 데이터만 선택적으로 호출하는 방식으로 해당 서비스에 맞는 API를 개발. 이를 통해 불필요한 데이터 수집을 제거하고, 필요한 데이터만 호출하여 응답 시간이 약 30% 단축되고 연간명세서 서비스의 성능이 최적화됨.
  - Monolithic -> MSA로 전환 시 어떻게 수정했는지 -> 기간계 I/F를 직접 호출해서 정제 + 어떻게 테스트했고 + 어떻게 step by step으로 진행했는지 + 기존서비스에 영향은 없었는지 + 서비스 방어로직(새로운 로직이 안되면 기존 로직 사용 등)
  - 어떻게 Monolithic 결과와 MSA의 결과가 같은지 확인했는지(라이브러리 등)
- **Redis 캐싱을 통한 성능 개선:**  
  소비분석 초화면에 지속적으로 노출되는 달성 태그, 지난 기간 소비금액 등의 데이터를 Redis 캐시에 저장하여 반복 호출을 최소화하고 전체 API 응답 성능을 추가로 개선.
  - 너무 단순하다 -> key setting, redis issue, mutable한 데이터는 어떻게 했는지, 안정성은 어떻게 확보했는지
  - 초화면에서의 성능 개선 더 한거
  - redis가 죽었을때의 대처(방어로직) -> 경험을 했기에 이런상황 발생해도 대처 가능
  - 피드 중에 에러가 발생하면 알람 -> 어드민으로 끄고 킬수있게 제작 

- **고액회원(6천만 원 이상) 대상 배치 및 NAS 저장:**
  서비스 및 기간계 I/F 실시간 호출로 인해 발생하는 DB 및 기간계 시스템의 부하를 줄이기 위해, 고액회원의 연간 데이터를 실시간 호출 대신 주기적 배치 및 NAS 저장/호출 방식으로 전환하여 시스템 안정성과 성능을 개선.
  - 6천만원 이상 고객 진입 시 실시간 호출 데이터가 많아 데이터 센터 부하 알람 발생
  - 오픈이 얼마 안남은 상황 NAS를 긴급하게 구축 일주일에 한번씩 배치

# 마이데이터 기반 금융 소비분석 프로젝트

**프로젝트 기간:** 2023년 2월 ~ 2023년 10월  
**기술 스택:** Spring Boot, Microservices Architecture (MSA), Spring Batch, Feign Client, Mybatis, Redis

## 주요 업무 및 성과:
- **SQL 재사용성을 고려한 금융 데이터 설계 및 최적화:**  
  마이데이터 기반의 금융 서비스에서 공통적으로 사용되는 **국내 및 해외 카드 소비 내역, 계좌 소비 데이터**를 효율적으로 조회하기 위해, **`WITH` 절을 사용해 공통 쿼리를 분리**하고 재사용성을 높임. 이를 통해 각 서비스에서 **효율적으로 금융 데이터를 처리**할 수 있도록 설계함.

- **개인화된 금융 소비 분석을 위한 서비스 쿼리 및 API 설계:**  
  **카드 및 계좌 이용 내역, 미사용 카드 목록, 특정 기간 소비금액, 또래 비교** 등 다양한 **14개의 금융 소비 관련 서비스**를 제공하기 위한 **서비스 쿼리와 API를 설계하고 개발**. 이를 통해 고객에게 **개인화된 금융 소비 분석 리포트**를 제공하여 맞춤형 금융 상품 추천과 소비 관리 기능을 강화함.

- **예산 설정 배치 처리 및 성능 최적화:**  
  **배치 작업의 안정성과 성능을 최적화**하기 위해 실행 횟수 제한, 재시도 메커니즘을 적용하고, 페이징과 데이터 정렬 방식의 최적화를 통해 **효율적인 대규모 데이터 처리**를 구현함.
  - retry, startlimit, flowstep 처리 내용 구체적으로 적기
  - 내가 주의해서 짯던 부분 에러났을때 어떻게 처리할건지
- **모니터링 및 에러 관리:**  
  배치 작업 중 발생하는 **에러를 실시간으로 관리**하고, 실패 시 알림을 통해 **모니터링 효율성**을 높임으로써 운영 효율성을 개선.
  - 배치작업 중 에러 났을때 어떻게 대처했는지 구체적으로
## 개선사항 : 쿼리 성능 50% 향상
  1. **쿼리 성능 개선 작업:** 무승인매입 및 정정 데이터 추출 시 WHERE 절 서브쿼리의 중복 조회되는 쿼리 블록을 제거하여 성능을 개선함(승인제외 및 정정제외).
  2. **실제 적재되는 데이터 기반 인덱스 추가:** 은행계좌내역 조회 시 **기관코드, 계좌번호, 이체시간**을 기준으로 인덱스를 추가하고, **이체금액, 이체시간, 계좌번호**로 추가 인덱스를 생성하여 성능을 향상시킴.
  3. **중복 IO 감소:** 자바로 처리되던 소비내역포함여부 데이터를 쿼리를 통해 금액제외여부, 포인트제외여부, 내계좌이체여부 등의 조건으로 처리하여 **중복 IO를 40% 감소**시킴.


## Application 구조개선 프로젝트
### 기술 스택: Spring Boot, MSA, Redis, REST API, 내부 메모리 캐시

### 주요 업무 및 성과:
- 로컬캐시매니저 뭐 썻는지 왜 썻느지
1. 트랜잭션 내 반복 조회 최적화: 한도 조회 및 마케팅 동의를 포함한 여러 MSA에서 반복적으로 데이터를 조회하는 경우, 내부 메모리 캐시를 도입하여 동일 트랜잭션 내에서 한번 조회된 데이터를 재사용하도록 구조를 개선.
2. 내부 메모리 캐싱 도입: 한 트랜잭션에서 한 번 조회된 데이터를 내부 메모리 캐시에 저장하여, 반복 호출을 방지하고 성능을 최적화. 이를 통해 API 응답 시간을 단축하고 시스템 부하를 줄임.
3. 인터페이스 호출 감소: 데이터 조회 시 캐시된 데이터를 활용함으로써, 한도 조회 및 마케팅 동의 등의 데이터 조회 인터페이스 호출을 20% 감소시켜 시스템 자원 소모를 최소화.
4. 시스템 성능 및 효율성 개선: 트랜잭션 내에서 데이터 호출 최적화를 통해 시스템 성능을 개선하고, 한 번의 호출로 불필요한 반복 조회를 방지하여 전반적인 성능 향상과 효율적인 자원 사용을 달성.

## 카드보유내역 I/F 조회 성능 개선 프로젝트
### 기술 스택: Spring Boot, Redis, REST API, @Cacheable

### 주요 업무 및 성과:
1. 카드보유내역 I/F 호출 부하 문제 해결: 회사에서 가장 큰 부하를 일으키는 카드보유내역 I/F 조회 문제를 해결하기 위해, 로그인 시 카드보유내역을 한 번 조회한 후 이를 Redis 캐시에 저장하는 방식으로 구조를 개선.
2. 데이터 일관성 유지: 카드 발급, 카드 삭제 등의 이벤트가 발생할 때 Redis 업데이트를 통해 데이터의 일관성을 유지하도록 시스템을 설계. 이를 통해 캐시된 카드보유내역이 항상 최신 상태로 유지되도록 함.
3. Redis 캐싱을 통한 성능 최적화: Redis 캐싱을 도입함으로써 카드보유내역 I/F 호출 빈도를 50% 감소시켜 시스템 부하를 크게 줄이고 성능을 최적화함.
4. @Cacheable을 활용한 효율적인 캐싱 처리: Spring의 @Cacheable 어노테이션을 사용하여, 캐싱 처리 로직을 간소화하고 성능을 최적화. 이를 통해 개발 생산성을 높이고 시스템의 유지 보수성을 강화함.

## 반복적 에러 해결 및 모니터링 시스템 개선 프로젝트
### 기술 스택: Spring Boot, Microservices Architecture (MSA), 모니터링 툴, Exception Handling, Logging
### 주요 업무 및 성과:
- SI들이 개발하고 간 불필요한 log.error제거 추가, 에러를 제거 -> 에러로그를 남발하면 안된다. 차라리 예외처리로직을 생성하자
- 실제로 현업들과 이야기해서 진짜 에러인지 아닌지 판단해서 불필요한 log.error는 제거
- 지금 하고 있는 grafana알람시스템(임계치설정으로 인해 알람이 가기 떄문에 log.error 코드작성에 유의해야함)
3. 반복적 에러 해결: 모니터링 툴에서 90%를 차지하는 동일한 반복적 에러(NPE, SQL PK 오류, StringIndexOutOfBoundsException 등)를 분석하여, MSA 전반에 걸쳐 총 16건의 반복적인 오류를 해결. 이를 통해 서비스 전반의 안정성을 크게 향상시킴.
2. 모니터링 가시성 개선: 반복적인 에러들을 제거함으로써, 모니터링 툴에서 실제 중요한 문제를 식별하기 어려웠던 상황을 개선하고 모니터링 가시성을 크게 향상시킴.
3. MSA 환경에서의 에러 관리: 각 마이크로서비스의 에러 발생 패턴을 분석하고, Exception Handling 및 로깅 전략을 도입하여 동일한 에러가 반복되지 않도록 시스템을 개선. 이를 통해 향후 시스템 문제 해결 시 대응 속도를 높임.
4. 시스템 안정성 및 유지보수성 강화: 반복적인 에러의 근본적인 원인을 파악하고 해결함으로써, 시스템의 안정성 및 유지보수성을 강화하여 운영 효율성을 높임.