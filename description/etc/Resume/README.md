# 삼성카드 소비분석 및 연간명세서 프로젝트

**프로젝트 기간:**
- 삼성카드 소비분석 : 2021년 11월 ~ 2022년 8월
- 삼성카드 소비분석 연간명세서 : 2022년 12월 ~ 2023년 1월

**기술 스택:** Spring Boot, Microservices Architecture (MSA), Feign Client, MyBatis, Redis

## 프로젝트 내용:
- 월평균 10만 명의 순사용자를 대상으로 고객의 소비 패턴을 분석하고, 카드 사용 실적 데이터를 종합적으로 분석한 프로젝트입니다. 이를 통해 고객 맞춤형 금융 상품 추천과 소비 분석 리포트를 제공했습니다
- 배치 : 해외 결제, 업종별 실적 등 총 22가지 금융 거래 데이터를 정기적인 배치 작업을 통해 관리하였습니다. .
- 실시간 : 소비 데이터를 실시간으로 분석해, 월간/분기별 소비 현황, 가맹점 이용 순위, 해외 결제 내역 등을 실시간으로 제공할 수 있는 기능을 구현했습니다. 이 과정에서 Microservices Architecture(MSA)로 시스템을 전환하면서 API 성능 최적화와 Redis 캐싱을 도입하여 응답 속도를 개선하고, 시스템 부하를 줄이는 작업을 수행했습니다.

### 주요 내용:
- **MSA 구조로의 전환 및 API 성능 30% 최적화**:  
  기존 Monolithic 구조를 MSA로 전환하면서 각 서비스의 DB 및 기간계 API를 직접 호출하여 필요한 데이터만 선택적으로 호출하는 API를 개발했습니다. 이를 통해 불필요한 데이터 호출을 최소화하고 응답 시간을 약 30% 단축했습니다.
  - 서비스 방어 로직 추가: MSA로의 전환 과정에서 **서비스의 안정성 확보**를 위해 방어 로직을 추가했습니다. 새로운 API 로직이 호출에 실패하거나 예기치 못한 오류가 발생할 경우, **Fallback 메커니즘**을 적용하여 **기존 Monolithic 구조의 로직으로 자동 전환**되도록 하였습니다.
  - API테스트 : Monolithic에서 MSA로 전환하는 과정에서는 Mock 데이터를 사용한 단위 테스트와, MSA 구조로 전환 후 기간계 I/F 데이터를 실시간으로 호출하여 테스트를 진행했습니다. API 응답 결과를 Monolithic과 비교하여 데이터 일관성을 확인했습니다.

- **Redis 캐싱을 통한 초화면 성능 개선**:  
  소비분석 초화면에 자주 노출되는 데이터를 Redis에 캐싱하여 반복 호출을 최소화하고 응답 속도를 개선했습니다. Redis Key 설정과 TTL 설정을 통해 효율적인 캐시 관리와 캐시 무효화 전략을 적용했습니다. 또한, Redis 장애 시 데이터베이스에서 데이터를 자동으로 가져오는 방어 로직을 추가하여 시스템 중단을 방지했습니다.
  - **캐싱한 데이터**: 2~4개월 전의 소비 데이터, 고객별 맞춤 소비피드 목록, 이미 달성한 고객 소비태그 등

- **연간명세서 고액회원(6천만 원 이상) 대상 배치 및 NAS 저장 시스템 구축**:  
  고액회원의 대규모 데이터를 실시간으로 호출하면서 발생하는 데이터 센터 부하를 해결하기 위해 NAS를 구축하고 일주일에 한 번 배치를 통해 데이터를 처리하는 방식으로 전환했습니다. 
  - NAS 도입 전에는 실시간 호출로 인해 데이터 센터에 과부하 알람이 발생했고, 이에 주기별 배치를 통해 NAS에 저장하는 방식으로 전환했습니다. 
  - 이를 통해 시스템 부하 없이 고액회원 데이터를 안정적으로 관리할 수 있었습니다.


# 마이데이터 기반 금융 소비분석 프로젝트

**프로젝트 기간:** 2023년 2월 ~ 2023년 10월  
**기술 스택:** Spring Boot, Microservices Architecture (MSA), Spring Batch, Feign Client, MyBatis, Redis

## 프로젝트 내용:
- 마이데이터 기반 금융 서비스에서 공통적으로 사용되는 **국내 및 해외 카드 소비 내역, 계좌 소비 데이터**를 효율적으로 조회하기 위해, **`WITH` 절을 사용해 공통 쿼리를 분리**하고 재사용성을 높임. 각 서비스에서 효율적으로 금융 데이터를 처리할 수 있도록 설계.
- **카드 및 계좌 이용 내역, 미사용 카드 목록, 특정 기간 소비금액, 또래 비교** 등 다양한 **14개의 금융 소비 관련 서비스**를 제공하기 위한 **서비스 쿼리와 API를 설계하고 개발**. 이를 통해 개인화된 금융 소비 분석 리포트를 제공.

### 배치 작업의 안정성과 성능 최적화:
고객들이 개별 카드에 예산을 설정하고, 설정한 예산의 특정 %를 소비하면 푸시 알림을 발송해주는 **배치 작업을 설계**.
- **Step Flow 구성:** 예산설정 고객, 카드, 예산금액 조회, 예산설정한 카드소비금액 조회, 알람금액과 조인, 앱푸시전송 테이블에 적재 
- **Retry 및 Skip 처리:** 특정 작업 실패 시 최대 3번의 Retry를 수행하고, 그 이후에도 실패 시 Skip하여 다음 Step으로 넘어가도록 설계함. 이 과정에서 실패한 작업은 별도로 로그에 저장해 후속 조치가 가능하게 함.
- **StartLimit 설정:** 각 Step에서 3회로 재시도 횟수를 제한하여 무한 재시도를 방지하고 안정성을 확보.
- **Chunk 기반 페이징 처리:** 대량 데이터를 효율적으로 처리하기 위해 Chunk 크기를 100으로 설정하여 한 번에 100개씩 데이터를 처리한 후 커밋하도록 설계. 페이징 처리 시 **offset**과 **limit**을 사용해 성능을 극대화.
- **Redis를 사용한 Skip 데이터 재처리:** Skip된 항목들은 **Redis**에 저장되며, 다시 재처리할 수 있도록 백업 배치를 설계함

### 성능 개선 작업:
- **쿼리 성능 개선 작업:** 무승인매입 및 정정 데이터 추출 시 WHERE 절 서브쿼리의 중복 조회되는 블록을 제거하여 성능을 개선함. 승인제외 및 정정제외 로직을 적용해 처리 시간을 단축.
- **실제 적재 데이터 기반 인덱스 추가:** 은행계좌내역 조회 시 기관코드, 계좌번호, 이체시간을 기준으로 인덱스를 추가하고, 이체금액, 이체시간, 계좌번호로 추가 인덱스를 생성하여 성능을 향상시킴.
- **중복 IO 감소:** 쿼리에서 소비내역포함여부 조건을 통해 금액제외여부, 포인트제외여부 등을 처리하여 중복 IO를 40% 감소시키고, 처리 시간을 9초에서 1초로 단축함.


# Application 구조개선 작업
**기술 스택:**: Spring Boot, MSA, Redis, REST API, 내부 메모리 캐시

## 작업 내용:
Application 구조개선 프로젝트에서는 한도 조회 및 마케팅 동의를 포함한 여러 MSA 서비스에서 발생하는 반복적인 데이터 조회 문제를 해결하기 위해 **내부 메모리 캐시(Ehcache)**를 도입했습니다. 이를 통해 각 트랜잭션 내에서 동일한 데이터를 반복적으로 조회하지 않도록 최적화하였으며, API 응답 시간을 단축하고 시스템 부하를 줄이는 성과를 달성했습니다.

### 주요 내용:
1. **트랜잭션 내 반복 조회 최적화**:  
   한도 조회 및 마케팅 동의와 같은 기능에서 **반복적으로 동일한 데이터를 조회**하는 경우, 이를 **로컬 캐시**에 저장하여 **동일 트랜잭션 내에서 데이터 재사용**이 가능하도록 구조를 개선했습니다. 이를 통해 불필요한 데이터베이스 및 외부 API 호출을 줄이고 시스템 성능을 크게 개선했습니다.
2. **내부 메모리 캐시(LocalCacheManager) 도입**:  
   각 트랜잭션 내에서 한 번 조회된 데이터를 **Ehcache**를 활용한 **LocalCacheManager**에 저장하여, 이후 동일 트랜잭션 내에서 발생하는 반복적인 데이터 호출을 방지했습니다. 이로 인해 데이터베이스나 외부 시스템과의 통신을 줄임으로써 **API 응답 시간을 단축**하고, **전체 시스템 부하를 줄이는 효과**를 거두었습니다.
3. **인터페이스 호출 20% 감소**:  
   내부 메모리 캐시에 데이터를 저장함으로써, 한도 조회 및 마케팅 동의 등의 서비스에서 **외부 인터페이스 호출을 약 20% 감소**시켰습니다. 이는 **데이터 조회 인터페이스**의 반복적인 호출을 줄여 전체 시스템 자원 소모를 최적화하였으며, 불필요한 네트워크 트래픽 및 I/O 작업을 감소시켜 성능을 크게 개선했습니다.
4. **시스템 성능 및 효율성 개선**:  
   **트랜잭션 내에서의 데이터 호출 최적화**를 통해 전체 시스템 성능을 크게 향상시켰습니다. 캐시된 데이터를 활용함으로써 불필요한 데이터베이스 및 API 호출을 줄여 **API 응답 시간을 단축**했으며, 이는 특히 대규모 트래픽 상황에서의 시스템 안정성을 크게 개선하는 데 기여했습니다. 또한 **리소스 사용을 효율화**하여 시스템의 전반적인 효율성을 높였습니다.
5. MDC와 Kibana를 통한 로그 가시성 향상:
   Ehcache와 **MDC**를 통합하여, **캐시 키 값(cacheKey)**을 MDC에 기록했습니다. 이를 통해 Kibana에서 해당 데이터를 시각화하고 분석할 수 있게 했습니다. 

# 카드보유내역 I/F 조회 성능 개선 작업
**기술 스택:**: Spring Boot, Redis, REST API, @Cacheable

## 작업 내용:
대 고객 서비스단에서 가장 많이 호출되는 카드보유내역 I/F를 Redis를 통해 저장/활용하여 I/F호출 50% 감소

### 주요 내용:
1. **카드보유내역 I/F 호출 부하 문제 해결**:  
   회사에서 가장 큰 부하를 발생시키는 카드보유내역 I/F 조회 문제를 해결하기 위해, **로그인 시 카드보유내역을 한 번 조회한 후 Redis 캐시에 저장**하는 방식으로 성능을 개선하였습니다. 이를 통해 동일한 데이터에 대한 반복적인 조회를 줄였습니다.

2. **데이터 일관성 유지**:  
   **카드 발급, 삭제** 등의 이벤트가 발생할 때 Redis 업데이트를 통해 캐시된 데이터를 최신 상태로 유지하도록 시스템을 설계했습니다. 이로써, 데이터 일관성이 보장되었습니다.

3. **Redis 캐싱을 통한 성능 최적화**:  
   Redis 캐싱을 적용하여 카드보유내역 I/F 호출 빈도를 **50% 감소**시켰습니다. 이를 통해 전체 시스템 부하를 줄이고 **응답 시간을 대폭 단축**하는 성과를 거두었습니다.

4. **@Cacheable을 활용한 캐싱 처리**:  
   Spring의 **@Cacheable 어노테이션**을 사용하여, Redis에 있는 경우 조회속도를 향상시키고, 없는 경우 DB에서 조회해 Redis에 적재하도록 진행했습니다. 


## 반복적 에러 해결 및 모니터링 시스템 개선 작업
**기술 스택:**: Spring Boot, Microservices Architecture (MSA), 모니터링 툴, Exception Handling, Logging

## 작업 내용:
MSA 환경에서 발생하는 반복적인 에러를 해결하고 모니터링 시스템의 가시성을 개선하며, 시스템 안정성을 높이는 작업을 수행했습니다. **에러 로그 최적화**와 **실시간 모니터링 시스템**을 구축하여, 서비스 전반의 안정성과 운영 효율성을 향상시켰습니다.

### 주요 내용:
1. **반복적 에러 해결**:  
   모니터링 툴에서 90%를 차지하던 동일한 반복적 에러(NPE, SQL PK 오류, StringIndexOutOfBoundsException 등)를 16건 해결하여 **시스템 장애 발생 빈도를 50% 감소**시켰습니다. 이를 통해 서비스 안정성을 크게 향상시켰습니다.

2. **불필요한 log.error 제거 및 예외 처리 로직 생성**:  
   **개발팀과 협업**하여 불필요한 log.error를 제거하고, **Exception Handling 로직**을 새로 구축하여 로그 남발을 방지했습니다. 이를 통해 모니터링 가시성을 높이고, 에러 발생 시 신속한 대응이 가능하도록 최적화했습니다.

3. **현업과의 협업을 통한 에러 판단**:  
   현업 부서와 긴밀히 협력하여 로그에 기록된 에러 중 실제로 중요한 문제를 판별하고, 불필요한 log.error를 제거했습니다. 이를 통해 에러 로그의 **정확성을 30% 향상**시켰습니다.

4. **모니터링 가시성 개선 및 실시간 경고 시스템 적용**:  
   반복적인 에러 제거로 모니터링 툴에서 중요한 문제를 더 쉽게 식별할 수 있었습니다. **Grafana**를 사용해 임계치 도달 시 실시간 알람이 발생하도록 설정하여 **에러 감지 시간을 20% 단축**시켰고, **log.error 코드 작성 시 임계치 설정**을 통해 효율적인 에러 관리와 모니터링을 실현했습니다.

5. **MSA 환경에서의 에러 관리**:  
   각 마이크로서비스의 에러 발생 패턴을 분석하고, **Exception Handling** 및 **로깅 전략**을 도입하여 동일한 에러가 반복되지 않도록 시스템을 개선했습니다. 이를 통해 서비스 문제 발생 시 **대응 속도를 40% 향상**시켰습니다.

6. **시스템 안정성 및 유지보수성 강화**:  
   반복적인 에러의 근본 원인을 해결함으로써 **시스템 안정성**과 **유지보수성**을 크게 강화하였고, 운영 효율성을 높여 서비스의 안정성과 가용성을 개선했습니다.
