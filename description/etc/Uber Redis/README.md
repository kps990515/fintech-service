## Uber Redis

1. CacheFront 읽기 및 쓰기, CDC 사용
   - CacheFront는 우버가 구축한 통합 캐시 솔루션으로, Redis, Docstore, 그리고 MySQL과 통합되어 동작
   - 데이터베이스에 접근하는 대신, Docstore의 쿼리 엔진이 Redis와 통신하여 읽기 요청을 처리
   - 캐시 적중(Cache hit) 시 Redis에서 데이터를 조회, 캐시 미스(Cache miss) 시에는 **데이터베이스(MySQL)**로 전달
   - 쓰기 요청의 경우, **Docstore의 CDC 서비스(Flux)**가 Redis의 기록을 **무효화
      - MySQL의 Binlog 이벤트를 추적하여 트리거되며, 데이터베이스에서의 업데이트가 Redis의 데이터를 무효화
2. 다중 지역 캐시 및 Redis 스트리밍
   - **지역 장애(fail-over)**가 발생할 경우 캐시 미스가 발생하여 데이터베이스에 과부하
     - 이를 해결하기 위해, 우버는 **다중 지역 간 Redis 복제(cross-region Redis replication)**를 사용
   - Region 1에서 발생한 쓰기 작업은 Region 2로 복제
   - Redis 스트리밍을 통해 원격 지역에 키가 복제되며, 스트림 소비자는 쿼리 엔진을 통해 데이터베이스에서 데이터를 읽어 캐시를 업데이트
3. Redis 및 Docstore 샤딩(Sharding)
   - Redis와 MySQL을 **샤딩(Sharding)**하여 부하를 분산 처리
   - Redis 클러스터와 MySQL 샤드가 별도로 운영되어, 특정 노드에 과부하가 발생하는 것을 방지

## 분산락의 6가지 주요 사용 케이스
1. 리더 선출
   - 한 번에 하나의 노드만 리더로 선출
   - 리더가 락을 획득하면 다른 팔로워(follower) 노드들은 락을 얻을 수 없음
   - 리더 노드를 선정하고 동시에 여러 리더가 선출되지 않도록 보장
2. 작업스케쥴링
   - 분산 락은 스케줄된 작업이 **한 번에 하나의 워커 노드(worker node)**에서만 실행되도록 보장
   - 중복 실행을 방지
3. 자원할당
   - 공유 리소스에 하나의 프로세스만 자원에 접근할 수 있도록 보장
   - 여러 프로세스가 동시에 자원을 사용할 때 발생할 수 있는 충돌을 방지
4. 마이크로서비스 조정
   - 여러 마이크로서비스가 관련 데이터를 동시에 업데이트해야 할 때, 분산 락은 이 작업이 질서 있고 통제된 방식으로 수행되도록 보장
   - 데이터베이스 간의 일관성을 유지
5. 재고관리
   - 동일한 재고가 중복 판매되는 상황을 방지
   - 분산 락을 통해 하나의 사용자만 재고를 업데이트
6. 세션 관리 
   - 분산 락은 한 번에 하나의 서버만 세션을 수정할 수 있도록 보장
   - 데이터 불일치 방지
   