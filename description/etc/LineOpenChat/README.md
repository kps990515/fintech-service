## Line OpenChat 개선

## 1. 페치 이벤트 API 요청 급증

### 기존구조
1. 메시지 전송, 리액션, 읽음을 이벤트로 간주
2. 이벤트 생성시 마다 오픈챗 서버에 저장(mysql, redis, hbase)
3. Kafka에 이벤트 전달
4. Publish 서버가 해당 이벤트 소비해 고객에게 서버 푸시
5. 고객들은 이벤트(Fetch)API 호출
6. 오픈챗 서버 부하 발생

### 문제점
- 5천명이 있으면 이벤트 생성 시 마다 5000개의 페치 이벤트API 발생
- 오픈챗 서버 스토리지 부하 발생

### 해결이 어려웠던 이유
- 챗 ID를 기반으로 샤딩
- 핫챗은 하나의 챗 ID이기 때문에 데이터 분산 불가능
- 하나의 샤드, 하나의 키로 데이터 몰림

### 해결방안 : 핫챗 감지 및 스로틀링
1. 시간마다 몇개의 페치 이벤트 API가 요청됐는지 감지
2. 임계점 넘으면 핫챗으로 감지해 Redis에 해당챗을 핫챗으로 저장
3. 서버 푸시 보내기전 Redis에서 핫챗인지 감지
4. 핫 챗일 경우 서버 푸시를 확률적으로 스로틀링해서 발송

## 2. 오픈챗 참여 요청 급증

### 기존구조
1. 참여요청 발생 시 멤버데이터를 Mysql에 저장
2. 저장하기 전 서브쿼리로 기존 멤버인지 조회
3. 2번으로 인해 Mysql에서 벌크 Insert구문으로 취급

### 문제점
- innodb_autoinc_lock_mode값이 1(AUTO-INCREMENT)
- 벌크 Insert에 해당 설정이 붙으면서 테이블 전체 락이 잡힘
- 테이블 락으로 인해 락 경합으로 부하 발생

### 해결법 1: Mysql 락 모드 변경
- innodb_autoinc_lock_mode = 2 (Interleaved 모드) 설정
- 테이블 락을 사용하지 않고, 각 트랜잭션이 필요한 AUTO-INCREMENT 값을 자유롭게 할당
- 키값이 연속적이지 않을 수는 있음

### 해결법 2: 조인 스로틀링 적용
- Kafka에 몇개의 요청이 들어오는지 감지
- MySQL임계치가 넘으면 '잠시 뒤 요청해주세요' 팝업 노출
- 갑자기 많은 요청이 들어오면 조인 스로틀링도 지연이 발생해 Mysql에 한번에 많은 부담을 줌
- 조인스로틀링에 Kafka가 아닌 앞단에 로컬 캐시를 사용해 임계치 설정

### 해결법 3: 서킷브레이커 & 벌크헤드
- 서킷 브레이커만 있는 경우 shard1에 문제가 생기면 ThreadPool을 공유하는 다른 shard에도 부하발생
- 벌크헤드 : ThreadPool을 분리해 각 샤드 요청을 개별적으로 처리하는 방식
- 벌크헤드를 넣어 각 shard에 개별적 ThreadPool을 제공해서 shard2, shard3는 동작 가능케함
#### 벌크헤드
    - 시스템 리소스를 독립된 구역으로 분리, 한 부분에서 문제가 발생해도 다른 부분에 영향을 미치지 않도록 보호하는 패턴
    - 한 서비스나 샤드에 문제가 생겼을 때 그 리소스만 격리하여 처리하고, 다른 서비스나 샤드는 정상적으로 동작
    - 고가용성, 안정성 보장


